---
layout:       post
title:        大二学生编写的五指棋程序
subtitle:     大二学生编写的五指棋程序
date:         2019-06-3 07:08:00
author:       "xuepro"
header-img:   "img/home_bg.jpg"
header-mask:  0.3
catalog:      true
multilingual: true
tags:
    - c++
---

```cpp
1. Chess.h
#pragma once //注：该行语句保证头文件只被编译一次
/*棋子类*/
class Chess{
    int color;
    int row;
    int column;
    public:
        //初始化成员列表
        Chess(int color, int row, int col):color(color), row(row), column(col){}

        //获取棋子颜色
        int getColor(){
            return color;
        }

        //获取棋子位置
        void getPosition(int &row, int &col){
            row = this->row;
            col = this->column;
        }

        //设置棋子颜色
        void setColor(int color){
            this->color = color;
        }

        //设置棋子位置
        void setPosition(int row, int col){
            this->row = row;
            this->column = col;
        }
};

2. Player.h
#pragma once
#include"Chess.h"
#include<string>
/*游戏参与者Player类*/
class Player{
    protected:
        int color;
        std::string id; //id为参与者名称
    public:
        /*注：此处涉及C++虚函数机制*/
        virtual Chess playChess(const int boardState[15][15]) = 0;

        //获取玩家ID
        std::string getId(){
            return id;
        }
};

3. PersonPlayer.h
#pragma once
#include"Player.h"
/*玩家类PersonPlayer，继承Player*/
class PersonPlayer :public Player{
    public:
        PersonPlayer(const int color, const std::string id);
        //给出下一步棋的位置
        Chess playChess(const int boardState[15][15]);
};

4. Board.h
#pragma once
#include "Chess.h"
/*棋盘类*/
class Board{
    static const int ROW = 15; //行数，固定
    static const int COLUMN = 15;//列数，固定
    int boardState[ROW][COLUMN]; //棋盘状态矩阵
    int lastrow;//上一步位置的行
    int lastcol;//上一步位置的列

    public:
        Board(){
            lastcol = lastrow = 0;
            for (int i = 0;i < 15;i++)
			    for (int j = 0;j < 15;j++)
				    boardState[i][j] = 0;
        }

        //向棋盘添加棋子
        void addChess(Chess chess);
        //获取棋盘状态矩阵
        void getBoardState(int boardState[15][15]);
};

5. AI.h
#pragma once
/*五子棋AI的相关结构及类的头文件*/
//坐标
struct Position
{
    int x;
    int y;
};

//棋局形势
struct Situation
{
    int win5;//5连，必胜
	int alive4;//活4
	int die4;//冲4
	int lowdie4;//冲4低级版本
	int alive3;//活3
	int tiao3;//跳3
	int die3;//眠3
	int alive2;//活2
	int lowalive2;//低级活2
	int die2;//眠2
	int safe;//对手安全位置，无法产生威胁，不需考虑
};

/*注：以下各函数的依赖关系为：
*getPosition()<-maxScore()<-getScore()<-judgeChessSituation()<-getType()<-judgeType()<-getChess()
*/
//AI类，核心功能类
class AI{
    private:
        //棋盘位置的标志（黑子，白子或无子）
	    static const int WHITE = 2;
	    static const int BLACK = 1;
	    static const int EMPTY = 0;

	    //各棋局形势对应编号
	    static const int WIN5 = 0;
	    static const int ALIVE4 = 1;
	    static const int DIE4 = 2;
	    static const int LOWDIE4 = 3;
        static const int ALIVE3 = 4;
        static const int TIAO3 = 5;
        static const int DIE3 = 6;
        static const int ALIVE2 = 7;
        static const int LOWALIVE2 = 8;
        static const int DIE2 = 9;
        static const int SAFE = 10;

	    //估值函数的分数评判标准
        static const int levelA = 999999;//成五
        static const int levelB = 10000;//成活4 或 双冲4 或 冲4活3
        static const int levelC = 5000;//双活3
        static const int levelD = 1000;//眠3高级活3
        static const int levelE = 500;//冲四
        static const int levelF = 400;//低级冲四
        static const int levelG = 100;//单活3
        static const int levelH = 90;//跳活3
        static const int levelI = 50;//双活2
        static const int levelJ = 10;//活2
        static const int levelK = 9;//低级活2
        static const int levelL = 5;//眠3
        static const int levelM = 2;//眠2
        static const int levelN = 1;//没有威胁
        static const int levelO = 0;//有子，不能下

        //获得当前方向的棋局数组chess，line表示方向线，包括横向，纵向，左上到右下，右上到左下等四个方向线
        void getChess(int chess[9], const int state[15][15], Position position, int color, int line);

        //判断当前方向的棋局形势，关键函数
        int judgeType(const int chess[9]);

        //综合四个方向判断棋局形势
        int judgeChessSituation(const int state[15][15], Position position, int color);

        //综合5个方向评判当前位置的棋局形势,根据形势，评判分值
        int getScore(Situation situation);

        //获得judgeSituation返回当前方向的棋局类型
        int getType(const int state[15][15], Position position, int color, int line);

        //依据分数判断最佳落子的位置
        Position maxScore(const int myscore[15][15], const int hisscore[15][15]);

        public:
            //开放接口，获取最优落子位置
            Position getPosition(const int boardState[15][15], int color);
};

6. AIplayer.h
#pragma once
#include "Player.h"
#include "AI.h"
/*AI方，继承Player*/
class AIplayer :public Player{
    AI ai; //生成AI系统

    public:
        AIplayer(const int color, const std::string id);
        //@override
        Chess playChess(const int boardState[15][15]);
};
7. Judge.h
#pragma once
/*裁判类*/
class Judge{
    int current_player; //当前执棋者，0黑方，1白方
    public:
    Judge(){current_player = 1;}
    // 判断当前比赛结果，0还将继续，1黑胜，2白胜，3和棋（棋盘满了）
    int judgeResult(const int boardState[15][15]);
    //下一个执棋手
    int nextPlayer(){
        if(current_player)
            current_player = 0;
        else
            current_player = 1;
        return current_player;
    }
};

8. Show.h
#pragma once
#include <string>
#include <iostream>
#include <cstdlib>
/*绘制棋盘状态及输出交互信息的Show类*/
class Show{
    std::string COORDS; //标记棋盘位置的字母坐标
    std::string BOARD;	//DOS字符绘制的棋盘
    public:
        Show(){
            COORDS = "   A B C D E F G H I J K L M N O";
            BOARD =    "┌┬┬┬┬┬┬┬┬┬┬┬┬┬┐"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"├┼┼┼┼┼┼┼┼┼┼┼┼┼┤"
							"└┴┴┴┴┴┴┴┴┴┴┴┴┴┘";
        }
        
        void setVisualble(const int chesspadstate[15][15], const std::string msg);//绘制函数
		//@overload
        void setVisualble(const std::string msg);//输出交互信息
};

9. Game.h
#pragma once
#include"Chess.h"
#include"Board.h"
#include"AIplayer.h"
#include"PersonPlayer.h"
#include"Judge.h"
#include"Show.h"
#include<string>
/*游戏引擎类*/
class Game{
    int pattern;  //游戏模式，人人或人机
    int first_player;   //先手
    std::string black_id, white_id; //玩家名称

    //生成棋盘，裁判，及展示类
    Show show;
    Board board;
    Judge judge;

    void getPattern();  //获取模式
    void getOrder();    //获取先手
    void getPlayerID(); //获取玩家名称
    
    public:
        Game(){pattern = -1;}
        void initGame();    //初始化游戏相关信息
        void startGame();   //启动游戏引擎
        void playGame(Player &black, Player &white, Judge &judge, Board &board, Show &show);
};

（二） CPP文件
1. AI.cpp
#include"AI.h"
#include<vector>
#include<iostream>

Position AI::getPosition(const int boardState[15][15], int color){
    int aiscore[15][15]{0}; //AI的分数
    int pescore[15][15]{0};	//玩家的分数
    int temp[15][15]{0};	//临时状态矩阵
    int ai_chess_color{color+1};	//棋盘状态标志=棋子标志+1
    int pe_chess_color;
    int flag{0};

	//判断是否刚开始下棋
    for(int i=0;i<15;i++){
        for(int j=0;j<15;j++){
            if(boardState[i][j]>0){
                flag = 1;
                break;
            }
        }
        if(flag)
            break;
    }
    if(!flag){
        Position pos = {7, 7};	//第一个棋默认置于中间
        return pos;
    }

	//还原最后一步的棋盘标志
    for (int i = 0;i < 15;i++) {
		for (int j = 0;j < 15;j++) {
			if (boardState[i][j]>2)
				temp[i][j] = boardState[i][j] - 2;
			else
				temp[i][j] = boardState[i][j];
		}
	}

	//估价
    for (int i = 0;i < 15;i++)
		for (int j = 0;j < 15;j++) {
			Position pos;
			int score;
			pos.x = i;
			pos.y = j;
			//我的分数
			score = judgeChessSituation(temp, pos, ai_chess_color);//返回当前形势分数
			aiscore[i][j] = score;

			if (ai_chess_color == BLACK)
			    pe_chess_color = WHITE;
			else
				pe_chess_color = BLACK;

			score = judgeChessSituation(temp, pos, pe_chess_color);//返回当前形势分数
			pescore[i][j] = score;
		}

	//根据分数，给出落子位置
	return maxScore(aiscore, pescore);
}

int AI::judgeChessSituation(const int state[15][15], Position pos, int color){
    Situation situ{0};//记录当前位置形势的变量

    //非空位
    if(state[pos.x][pos.y])
        return levelO;

    for(int line = 0;line<4;line++){
        int type{getType(state, pos, color, line)};

        switch (type)
        {
		case WIN5:
			situ.win5++;
			break;
		case ALIVE4:
			situ.alive4++;
			break;
		case DIE4:
			situ.die4++;
			break;
		case LOWDIE4:
			situ.lowdie4++;
			break;
		case ALIVE3:
			situ.alive3++;
			break;
		case TIAO3:
			situ.tiao3++;
			break;
		case DIE3:
			situ.die3++;
			break;
		case ALIVE2:
			situ.alive2++;
			break;
		case LOWALIVE2:
			situ.lowalive2++;
			break;
		case DIE2:
			situ.die2++;
			break;
		case SAFE:
			situ.safe++;
			break;
        default:
            std::cout<<"错误";
            break;
        }
    }

    return getScore(situ);
}

int AI::getScore(Situation situ){
    int die4{situ.die4 + situ.lowdie4};
	int alive3{situ.alive3 + situ.tiao3};
	int alive2{situ.alive2 + situ.lowalive2};

	if (situ.win5 >= 1)
		return levelA;//五子成一线，必胜

	if (situ.alive4 >= 1 || die4 >= 2 || (die4 >= 1 && alive3 >= 1))
		return levelB;//活4，双冲4，冲4活3

	if (alive3 >= 2)
		return levelC;//双活3

	if (situ.die3 >= 1 && situ.alive3 >= 1)
		return levelD;//眠3,高级活3（即一定形成活4的活3）

	if (situ.die4 >= 1)
		return levelE;//高级冲4

	if (situ.lowdie4 >= 1)
		return levelF;//低级冲4

	if (situ.alive3 >= 1)
		return levelG;//单活3

	if (situ.tiao3 >= 1)
		return levelH;//跳活3

	if (alive2 >= 2)
		return levelI;//双活2

	if (situ.alive2 >= 1)
		return levelJ;//活2

	if (situ.lowalive2 >= 1)
		return levelK;//低级活2

	if (situ.die3 >= 1)
		return levelL;//眠3

	if (situ.die2 >= 1)
		return levelM;//眠2

	return levelN;//无威胁
}

int AI::getType(const int state[15][15], Position pos, int color, int line){
    int type;
    int chess[9]{0};

    getChess(chess, state, pos, color, line);
	type = judgeType(chess);

	return type;
}

void AI::getChess(int chess[9], const int state[15][15], Position pos, int color, int line){
    int pecolor;
	if(color == BLACK)
		pecolor = WHITE;
	else
	{
		pecolor = BLACK;
	}
	chess[4] = color;
	switch (line)
	{
	case 0://横向
		for(int j=1;j<=4;j++){
			//往左探索四个位置的状态
			int col = pos.y-j;
			if(col<0){
				for(;j<=4;j++)
					chess[4-j] = pecolor;//出界的位置填充玩家的颜色
				break;
			}
			chess[4-j] = state[pos.x][col];
		}

		for(int j=1;j<=4;j++){
			//往右探索四个位置的状态
			int col = pos.y+j;
			if(col>14){
				for(;j<=4;j++)
					chess[4+j] = pecolor;
				break;}
			chess[4+j] = state[pos.x][col];
		}
		break;

	case 1:	//纵向
		for(int j=1;j<=4;j++){
		//往上探索四个位置的状态
			int row = pos.x-j;
			if(row<0){
				for(;j<=4;j++)
					chess[4-j] = pecolor;
			break;}
			chess[4-j] = state[row][pos.y];
		}

		for(int j=1;j<=4;j++){
		//往下探索四个位置的状态
			int row = pos.x+j;
			if(row>14){
				for(;j<=4;j++)
					chess[4+j] = pecolor;
			break;}
			chess[4+j] = state[row][pos.y];
		}
		break;

	case 2://左上
		for (int i = 1, j = 1;i <= 4;i++,j++) {
			//往左上探索四个位置
			int row = pos.x - i;
			int column = pos.y - j;
			if (row < 0 || column <0) {//其中一个出边界
				for (;i <= 4;i++)
					chess[4 - i] = pecolor;//出界设置对手颜色
				break;
			}
			chess[4 - i] = state[row][column];//没出界，复制state数组
		}

		for (int i = 1, j = 1;i <= 4;i++, j++) {
			//往右下探索四个位置
			int row = pos.x + i;
			int column = pos.y + j;
			if (row > 14 || column > 14) {//其中一个出边界
				for (;i <= 4;i++)
					chess[4 + i] = pecolor;//出界设置对手颜色
				break;
			}
			chess[4 + i] = state[row][column];//没出界，复制state数组
		}
		break;

	case 3://右上
		for (int i = 1, j = 1;i <= 4;i++,j++) {
			//往左下探索四个位置
			int row = pos.x + i;
			int column = pos.y - j;
			if (row > 14 || column < 0) {//其中一个出边界
				for (;i <= 4;i++)
					chess[4 - i] = pecolor;//出界设置对手颜色
				break;
			}
			chess[4 - i] = state[row][column];//没出界，复制state数组
		}

		for (int i = 1, j = 1;i <= 4;i++, j++) {
			//往右上探索四个位置
			int row = pos.x - i;
			int column = pos.y + j;
			if (row < 0 || column > 14) {//其中一个出边界
				for (;i <= 4;i++)
					chess[4 + i] = pecolor;//出界设置对手颜色
				break;
			}
			chess[4 + i] = state[row][column];//没出界，复制state数组
		}
		break;

	default:
		break;
	}
}

//AI核心算法，判断当前方向的棋局形势，作为打分依据
int AI::judgeType(const int chess[9]){
	int aicolor = chess[4];
	int pecolor{3-aicolor};

	int left_pos, right_pos;
	int left_color, right_color;
	int count{1};

	for(int i=1;i<=4;i++){
		if(chess[4-i] == aicolor)
			count++;
		else{
			left_pos = 4-i;
			left_color = chess[4-i];
			break;
		}
	}

	for (int i = 1;i <= 4;i++) {
		if (chess[4 + i] == aicolor)
			count++;//同色
		else {
			right_pos = 4 + i;//存储断开位置
			right_color = chess[4 + i];//存储断开颜色
			break;
		}
	}

	if(count == 5)//5连，必胜
		return WIN5;

	if(count == 4){//中心线4连
		if(left_color == EMPTY && right_color == EMPTY)
			return ALIVE4;
		else if(left_color == pecolor && right_color == pecolor)
			 return SAFE;
		else
			return DIE4;
	}

	if(count == 3){//中心线3连
		int left_color1 = chess[left_pos-1];
		int right_color1 = chess[right_pos+1];

		if(left_color == EMPTY && right_color == EMPTY){//两边断开位置均空
			if(left_color1 == pecolor && right_color1 == pecolor)
				return DIE3;
			else if(left_color1 == aicolor || right_color1 == aicolor)//均为AI方棋子
				return LOWDIE4;
			else if(left_color1 == EMPTY || right_color1 == EMPTY)//两边断开位置只有一个空
				return ALIVE3;
		}
		else if(left_color == pecolor && right_color == pecolor){//均为对手棋子
			return SAFE;
		}
		else{
			if(left_color == pecolor){//左边被对方堵住
				if(right_color1 == pecolor)//右边也被对方堵住
					return SAFE;
				if(right_color1 == EMPTY)//右边均空
					return DIE3;
				if(right_color1 == aicolor)
					return LOWDIE4;
			}

			if(right_color == pecolor){
				if(left_color1 == pecolor)
					return SAFE;
				if(left_color1 == EMPTY)
					return DIE3;
				if(left_color1 == aicolor)//左边还有AI的棋子
					return LOWDIE4;
			}
		}
	}

	if(count==2){//中心线2连
		int left_color1 = chess[left_pos - 1];
		int right_color1 = chess[right_pos + 1];
		int left_color2 = chess[left_pos - 2];
		int right_color2 = chess[right_pos + 2];

		if(left_color == EMPTY && right_color == EMPTY){
			if((right_color1 == EMPTY && right_color2 == aicolor)||
			(left_color1 == EMPTY && left_color2 == aicolor))
				return DIE3;
			else if(left_color1 == EMPTY && right_color1 == EMPTY)
				return ALIVE2;

			if((right_color1 == aicolor && right_color2 == pecolor)||
			(left_color1 == aicolor && left_color2 == pecolor))
				return DIE3;

			if((right_color1 == aicolor && right_color2 == aicolor)||
			(left_color1 == aicolor && left_color2 == aicolor))
				return LOWDIE4;

			if((right_color1 == aicolor && right_color2 == EMPTY)||
			(left_color1 == aicolor && left_color2 == EMPTY))
				return TIAO3;
		}

		else if(left_color == pecolor && right_color == pecolor)
			return SAFE;

		else{//两边断开位置只有一个空
			if(left_color == pecolor){//左边被对方堵住
				if(right_color1 == pecolor || right_color2 == pecolor)//只要有对方的一个棋子
					return SAFE;
				else if(right_color1 == EMPTY && right_color2 == EMPTY)//均空
					return DIE2;
				else if(right_color1 == aicolor && right_color2 == aicolor)
					return LOWDIE4;
				else if(right_color1 == aicolor || right_color2 == aicolor)//只有一个AI的棋子
					return DIE3;
			}

			if(right_color == pecolor){
				if(left_color1 == pecolor || left_color2 == pecolor)
					return SAFE;
				else if(left_color1 == EMPTY && left_color2 == EMPTY)
					return DIE2;
				else if(left_color1 == aicolor && left_color2 == aicolor)
					return LOWDIE4;
				else if(left_color1 == aicolor || left_color2 == aicolor)
					return DIE3;
			}
		}
	}

	if(count == 1){//孤子
		int left_color1 = chess[left_pos - 1];
		int right_color1 = chess[right_pos + 1];
		int left_color2 = chess[left_pos - 2];
		int right_color2 = chess[right_pos + 2];
		int left_color3 = chess[left_pos - 3];
		int right_color3 = chess[right_pos + 3];

		if(left_color == EMPTY && left_color1 == aicolor &&
			left_color2 == aicolor && left_color3 == aicolor)
			return LOWDIE4;

		if(right_color == EMPTY && right_color1 == aicolor &&
			right_color2 == aicolor && right_color3 == aicolor)
			return LOWDIE4;

		if (left_color == EMPTY && left_color1 == aicolor &&
			left_color2 == aicolor && left_color3 == EMPTY && right_color == EMPTY)
			return TIAO3;

		if (right_color == EMPTY && right_color1 == aicolor &&
			right_color2 == aicolor && right_color3 == EMPTY && left_color == EMPTY)
			return TIAO3;

		if (left_color == EMPTY && left_color1 == aicolor &&
			left_color2 == aicolor && left_color3 == pecolor && right_color == EMPTY)
			return DIE3;

		if (right_color == EMPTY && right_color1 == aicolor &&
			right_color2 == aicolor && right_color3 == pecolor && left_color == EMPTY)
			return DIE3;

		if (left_color == EMPTY && left_color1 == EMPTY &&
			left_color2 == aicolor && left_color3 == aicolor)
			return DIE3;

		if (right_color == EMPTY && right_color1 == EMPTY &&
			right_color2 == aicolor && right_color3 == aicolor)
			return DIE3;

		if (left_color == EMPTY && left_color1 == aicolor &&
			left_color2 == EMPTY && left_color3 == aicolor)
			return DIE3;

		if (right_color == EMPTY && right_color1 == aicolor &&
			right_color2 == EMPTY && right_color3 == aicolor)
			return DIE3;

		if (left_color == EMPTY && left_color1 == aicolor &&
			left_color2 == EMPTY && left_color3 == EMPTY && right_color == EMPTY)
			return LOWALIVE2;

		if (right_color == EMPTY && right_color1 == aicolor &&
			right_color2 == EMPTY && right_color3 == EMPTY && left_color == EMPTY)
			return LOWALIVE2;

		if (left_color == EMPTY && left_color1 == EMPTY &&
			left_color2 == aicolor && left_color3 == EMPTY && right_color == EMPTY)
			return LOWALIVE2;

		if (right_color == EMPTY && right_color1 == EMPTY &&
			right_color2 == aicolor && right_color3 == EMPTY && left_color == EMPTY)
			return LOWALIVE2;
	}
	return SAFE;	//其他的情况意义不大，均返回无威胁形势
}

Position AI::maxScore(const int aiscore[15][15], const int pescore[15][15]){
	Position pos{0, 0};
	int max_ai_score{0};
	int max_pe_score{0};

	std::vector<Position> ai_pos;//vector容器存储最大分数对应的位置
	std::vector<Position> pe_pos;

	//求出AI的最大值向量
	for(int i=0;i<15;i++)
	for(int j=0;j<15;j++){
		if(aiscore[i][j] == max_ai_score){
			pos.x = i;
			pos.y = j;
			ai_pos.push_back(pos);
		}
		if(aiscore[i][j]>max_ai_score){
			max_ai_score = aiscore[i][j];
			ai_pos.clear();
			pos.x = i;
			pos.y = j;
			ai_pos.push_back(pos);
		}
	}

	//求出玩家的最大值向量
	for(int i=0;i<15;i++)
	for(int j=0;j<15;j++){
		if(pescore[i][j] == max_pe_score){
			pos.x = i;
			pos.y = j;
			pe_pos.push_back(pos);
		}
		if(pescore[i][j]>max_pe_score){
			max_pe_score = pescore[i][j];
			pe_pos.clear();
			pos.x = i;
			pos.y = j;
			pe_pos.push_back(pos);
		}
	}

	//选择攻
	if(max_ai_score >= max_pe_score){
		int temp{0};//存储对手的最有利位置的分数

		std::vector<Position>::iterator iter;
		for(iter=ai_pos.begin();iter!=ai_pos.end();iter++)
		{
			Position temp_pos = *iter;/*生成迭代器*/
			if(pescore[temp_pos.x][temp_pos.y] >= temp){
				temp = pescore[temp_pos.x][temp_pos.y];
				pos = temp_pos;
			}
		}

		return pos;//返回最终选择的落子位置
	}

	//选择守
	else{
		int temp{0};//存储AI的最有利位置的分数

		std::vector<Position>::iterator iter;
		for(iter=pe_pos.begin();iter!=pe_pos.end();iter++)
		{
			Position temp_pos = *iter;
			if(aiscore[temp_pos.x][temp_pos.y] >= temp){
				temp = aiscore[temp_pos.x][temp_pos.y];
				pos = temp_pos;
			}
		}

		return pos;
	}
}

2. AIplayer.cpp
#include"AIplayer.h"
AIplayer::AIplayer(const int color, const std::string id){
    this->color = color;
    this->id = id;
}

Chess AIplayer::playChess(const int boardState[15][15]){
    Position pos;
    pos = ai.getPosition(boardState, color);

    return Chess(color, pos.x, pos.y);
}

3. PersonPlayer.cpp
#include "PersonPlayer.h"
#include <iostream>
#include<windows.h>

PersonPlayer::PersonPlayer(const int color, const std::string id){
    this->color = color;
    this->id = id;
}

Chess PersonPlayer::playChess(const int boardState[15][15]){
    int i, j;
    char a, b;
    while(true){
        std::cout << "请输入下步棋，如H行A列,则输入HA即可(大写):";
		std::cin.clear();/*注：该操作清空输入流*/
		std::cin.sync();
		std::cin >> a;
		std::cin >> b;
        if('A' > a || a > 'O' || 'A' > b || b > 'O'){
            std::cout<<"字符非法，请重新输入！\n";
            Sleep(1);
            continue;
        }
        i = a-'A';
        j = b-'A';
        if(boardState[i][j]){
            std::cout<<"该位置已经有棋子，请下别的位置\n";
            continue;
        }
        else
            break;
    }
    return Chess(color, i, j);
}

4. Judge.cpp
#include"Judge.h"
int Judge::judgeResult(const int boardState[15][15]){
    int flag{0};
    int lastrow,lastcol;
    int result;

    for(int i=0;i<15;i++){
        for(int j=0;j<15;j++){
            if(!boardState[i][j]){
                flag = 1;
                break;
            }
        }
        if(flag)
            break;
    }
    if(!flag)
        return 3;//棋盘满，和局

    flag = 0;
    for (int i = 0;i < 15;i++) {//最后一步的坐标
		for (int j = 0;j < 15;j++)
			if (boardState[i][j]>2) {
				lastrow = i;
				lastcol = j;
				result = boardState[i][j] - 2;//返回当前旗手赢的标志
				flag = 1;
				break;
			}
		if (flag)
			break;
	}
	if (!flag)//还没开始下棋
		return 0;

    //横向
    int count{0};
    int mincol{lastcol-4 < 0 ? 0:lastcol - 4};
    int maxcol{lastcol + 4 > 14 ? 14 : lastcol + 4};
    for (int i = lastrow, j = mincol;j <= maxcol;j++) {
	    if (boardState[i][j] == result || boardState[i][j] == result + 2) {//返回结果标志和棋标志相同
			count++;
			if (count == 5)//赢了
				return result;
		}
		else 
			count = 0;//重头数起
	}

    //纵向
    count = 0;
	int minrow{lastrow - 4 < 0 ? 0 : lastrow - 4};
	int maxrow{lastrow + 4 > 14 ? 14 : lastrow + 4};
	for (int i = minrow, j = lastcol;i <= maxrow;i++) {
		if (boardState[i][j] == result || boardState[i][j] == result + 2) {//返回结果标志和棋标志相同
			count++;
			if (count == 5)//赢了
				return result;
		}
		else
			count = 0;//重头数起
	}

    //左上
    count = 0;
	minrow = lastrow - 4;
	mincol = lastcol - 4;
	if (minrow < 0 || mincol < 0) {//出界
		if (lastrow > lastcol) {//出界步数小先出界
			mincol = 0;//先出界的为边界值
			minrow = lastrow - lastcol;//后出界的根据斜率1
		}
		else {
			minrow = 0;
			mincol = lastcol - lastrow;
		}
	}
	maxrow = lastrow + 4;
	maxcol = lastcol + 4;
	if (maxrow > 14 || maxcol > 14) {//出界
		if (14 - lastrow < 14 - lastcol) {//出界步数小先出界
			maxrow = 14;//先出界的为边界值
			maxcol = lastcol + 14 - lastrow;
		}
		else {
			maxcol = 14;
			maxrow = lastrow + 14 - lastcol;
		}
	}
	for (int i = minrow, j = mincol;i <= maxrow;i++, j++) {
		if (boardState[i][j] == result || boardState[i][j] == result + 2) {//返回结果标志和棋标志相同
			count++;
			if (count == 5)//赢了
				return result;
		}
		else
			count = 0;//重头数起
	}

    //右上
    count = 0;
	minrow = lastrow - 4;
	maxcol = lastcol + 4;
	if (minrow < 0 || maxcol>14) {//出界
		if (lastrow - 0 < 14 - lastcol) {//出界步数小先出界
			minrow = 0;//先出界为边界值
			maxcol = lastcol + lastrow;
		}
		else {
			maxcol = 14;
			minrow = lastrow - (14 - lastcol);
		}
	}
	maxrow = lastrow + 4;
	mincol = lastcol - 4;
	if (maxrow > 14 || mincol < 0) {//出界
		if (14 - lastrow < lastcol - 0) {//出界步数小先出界
			maxrow = 14;
			mincol = lastcol - (14 - lastrow);
		}
		else {
			mincol = 0;
			maxrow = lastrow + lastcol - 0;
		}
	}	
	for (int i = minrow, j = maxcol;i <= maxrow;i++, j--) {
		if (boardState[i][j] == result || boardState[i][j] == result + 2) {//返回结果标志和棋标志相同
			count++;
			if (count == 5)//赢了
				return result;
		}
		else
			count = 0;//重头数起
	}

    return 0;//还将继续
}

5. Board.cpp
#include"Board.h"
void Board::addChess(Chess chess){
    if (boardState[lastrow][lastcol])//有棋子
		boardState[lastrow][lastcol] -= 2;//不是最后一步了

	chess.getPosition(lastrow, lastcol);//重新设置最后一步记录

	if (chess.getColor())//白棋
		boardState[lastrow][lastcol] = 4;
	else//黑棋
		boardState[lastrow][lastcol] = 3;
}

void Board::getBoardState(int boardState[15][15]){
    for(int i=0;i<15;i++)
    for(int j=0;j<15;j++)
        boardState[i][j] = this->boardState[i][j];
}

6. Show.cpp
#include "Show.h"
using namespace std;

void Show::setVisualble(string msg){
    int initState[15][15]{0};
    setVisualble(initState, msg);
}

void Show::setVisualble(const int boardState[15][15], const string msg){
    system("cls");//先清屏
	cout << COORDS << endl;//列号
	for (int row = 0;row < 15;row++) {//第row行
		cout << COORDS.at((row + 1) * 2 + 1) << " ";//行号
		for (int col = 0;col < 15;col++) {//第col列
			switch (boardState[row][col]) {
				case 0://空白
					cout << BOARD.at((row * 15 + col) * 2)
						<< BOARD.at((row * 15 + col) * 2 + 1);
					break;
				case 1://黑棋
					cout << "○";
					break;
				case 2://白旗
					cout << "●";
					break;
				case 3://黑棋(最后一步)
					cout << "▽";
					break;
				case 4://白棋(最后一步)
					cout << "▼";
					break;
				default:
					cout<<"错误";
					break;
			}
		}
		cout << endl;
	}
	cout << msg;
}

7. Game.cpp
#include"Game.h"
#include<iostream>
using namespace std;

void Game::getPattern(){
    do {
		show.setVisualble("选择游戏模式0为人机对弈，1为人人对弈：");
		cin.clear();
		cin.sync();
		cin >> pattern;
	} while (2 <= pattern || pattern < 0);
}

void Game::getOrder(){
    do {//选择顺序
		show.setVisualble("电脑先下请输入0，你先下请输入1：");
		cin.clear();
		cin.sync();
		cin >> first_player;
	} while (2 <= first_player || first_player < 0);
}

void Game::getPlayerID(){
    if(pattern){
        show.setVisualble("请输入黑方棋手的名称（默认黑方先下）：");
		cin.clear();
		cin.sync();
		getline(cin, black_id);
		show.setVisualble("请输入白方棋手的名称（默认黑方先下）：");
		cin.clear();
		cin.sync();
		getline(cin, white_id);
    }

    else{
        getOrder();
        if(first_player){
            black_id = "你";
            white_id = "AI";
        }
        else{
            black_id = "AI";
            white_id = "你";
        }
    }
}

void Game::initGame(){
    getPattern();
    getPlayerID();
}

void Game::startGame(){
    if (pattern) {//人人模式

		//初始化选手
		PersonPlayer black(0, black_id);
		PersonPlayer white(1, white_id);
		//下棋
		playGame(black, white, judge, board, show);
	}
	else {//人机
		if (first_player) {//AI后下

			//初始化选手
			AIplayer white(1, "AI");
			PersonPlayer black(0, "你");
			//下棋
			playGame(black, white, judge, board, show);
		}
		else {//AI先下

			//初始化选手
			AIplayer black(0, "AI");
			PersonPlayer white(1, "你");
			//下棋
			playGame(black, white, judge, board, show);
		}
	}
}

void Game::playGame(Player &black, Player &white, Judge &judge, Board &board, Show &show){
    int result;
	int state[15][15]{0};
	//下棋阶段
	while (!(result = judge.judgeResult(state))) {
		if (judge.nextPlayer()) {
			show.setVisualble(state, "白方：" + white.getId() + "\n");
			board.addChess(white.playChess(state));
		}
		else {
			show.setVisualble(state, "黑方：" + black.getId() + "\n");
			board.addChess(black.playChess(state));
		}
		board.getBoardState(state);
	}
	//显示结果
	switch (result) {
	case 1:
		show.setVisualble(state, "黑方:" + black.getId() + "胜\n请按e键退出");
		break;
	case 2:
		show.setVisualble(state, "白方:" + white.getId() + "胜\n请按e键退出");
		break;
	case 3:
		show.setVisualble(state, "本局结束，你们打平\n请按e键退出");
		break;
	default:
		cout<<"错误";
		break;
	}
	//退出
	char exit;
	do {
		cin.clear();
		cin.sync();
		cin >> exit;
	} while (exit != 'e' && exit != 'E');
}

8. main.cpp
#include "Game.h"
/*五子棋项目主函数*/
int main() {
	Game game;
	game.initGame();
	game.startGame();
}

```
