---
layout:       post
title:        "控制台字符游戏 “射击游戏”"
subtitle:     "shhoter console game program"
date:         2018-05-24 11:12:00
author:       "xuepro"
header-img:   "img/home_bg.jpg"
header-mask:  0.3
catalog:      true
multilingual: true
tags:
    - C++
    
---    

这2天让学生学习我的好友河海大学童晶老师的“做游戏、学C语言”的课程，我自己也顺便看了一下，发现这种讲课模式非常好、非常受学生欢迎。尽管之前，
童老师和我说他一直用做游戏方式教学生学C语言，我一直没在意。 我今天早上用他书中的“射击游戏”为示例写了一个控制台模式下的字符游戏框架，希望小朋友将我这个程序中的许多对象如画布（canvas）、各种精灵(如射击者shooter、子弹bullet、敌人enemy等)改成C++的类，并用C++的colletion类如vector等管理所有精灵和对象（敌人、子弹），另外还应该添加其他如随机出现敌人、敌机追击你等功能。 
![](https://wx3.sinaimg.cn/mw690/006Lkwkygy1frqwqu0m5cj30e90c63yv.jpg)

想进一步学习C++游戏编程，可以参加我的暑假的6天"C++小白做游戏"线下课程。具体报名请在微博“教小白精通编程”里找。也可以购买童老师的书《C语言课程设计与游戏开发实践教程》.

还可以参考我前几年的上课时的本科生写的比如[纸牌类Desk(](http://hwdong.com/c++/Desk.zip)、[贪吃蛇程序](http://hwdong.com/c++/snake.exe),写出各种各样的控制台字符游戏！

### 游戏程序的框架

我们知道一个游戏就是一个随时间变化的画面，每一时刻的画面包括背景图像和一些动态物体（称为精灵）的图像。
游戏一开始会进行一些初始化工作，然后显示开始画面，根据用户的输入游戏中的元素（对象）会发生变化，从而导致画面产生变化。
游戏的过程通常一直循环地“处理用户输入、更新游戏的数据、绘制场景”，因此，所有游戏具有如下的程序结构或框架：

```cpp
int main()
{
     //初始化
     
     setup();

     while(1){
	processInput();   //处理用户输入
	
	update();         //更新游戏数据
	
	renderScene();    //绘制场景
	
	show();           //显示游戏画面（即图像）—
     }
     
     return 0;
}
```

游戏的场景需要在一个游戏窗口的绘制屏幕上进行绘制，对于现代的游戏，绘制屏幕可以看成一幅图像，比如我们的电脑屏幕就是一个绘制屏幕，操作系统在上面绘制各种图标。即形成所谓的GUI用户界面。这个屏幕是具有一定分辨率（比如1024```*```768)的画板或画布，也就是画布由一些所谓的“像素”构成的，每个像素可以具有不同的颜色，我们只要对这些像素设置相应的颜色就可以表示各种物体。

**控制台游戏(Console Game)** 中没有通常的图形（图像）的那种像素式绘制屏幕（画布），其中显示的最小单位不是我们通常的屏幕“像素”而是“字符”，尽管如此，我们也可以将控制台窗口看成一块画布(Canvas)，而每个位置能显示各种字符，这些位置的字符可以看成“像素”。

因此，我们控制台游戏的窗口可以看成“颜色是各种字符”的画布。一个画布主要包括长、宽和存储每个像素的画布空间。因此，我们可以如下的画布：
```cpp
//==========画布==========

 const int canvas_width = 50,canvas_height=20; //画布canvas的长宽
 
 char canvas[canvas_height][canvas_width];     //画布内容是一个“像素是字符”的矩阵（矩形区域）
```
我们可以用**宏定义**来定义画布的其他属性，比如背景颜色、边框颜色等。
```cpp
#define background_color '.'

#define boundary_color '+'
```

游戏每一时刻的画面绘制，通常先清空整个画布，即显示一个没有任何对象的空的背景画布。

我们可以通过一个辅助函数来清空画布。
```cpp
//---------清空画布--------

void clear_canvas(){
     for(int y = 0; y<canvas_height;y++)
		  for(int x = 0; x<canvas_width;x++)
              canvas[y][x] = background_color;
     int right  =canvas_width-1;
     for(int y = 0; y<canvas_height;y++){
        canvas[y][0] = background_color;
        canvas[y][right] = background_colo;
     }
     int bottom  =canvas_height-1;
     for(int x = 0; x<canvas_width;x++){
        canvas[0][x] = background_color;
        canvas[bottom][x] = background_color;
     }
}
```
我们可以"输出作为颜色的字符"显示这个空白的画布.
```cpp
void show(){
  for(int y = 0; y< canvas_height;y++){
     for(int x = 0; x< canvas_width;x++)
	  std::cout<<canvas[y][x];
      std::cout<<'\n'; 
}
	
```
下面这个程序将显示一个空白的干净的画布
```cpp
#include <iostream>

using namespace std;

//---------常用的颜色-------

#define background_color '.'

#define boundary_color '+'


//==========画布==========

 const int canvas_width = 50,canvas_height=20; //画布canvas的长宽
 
 char canvas[canvas_height][canvas_width];     //画布内容是一个“像素是字符”的矩阵（矩形区域）
 
 
//---------清空画布--------

void clear_canvas(){
     for(int y = 0; y<canvas_height;y++)
		  for(int x = 0; x<canvas_width;x++)
              canvas[y][x] = background_color;
     int right  =canvas_width-1;
     for(int y = 0; y<canvas_height;y++){
        canvas[y][0] = background_color;
        canvas[y][right] = background_colo;
     }
     int bottom  =canvas_height-1;
     for(int x = 0; x<canvas_width;x++){
        canvas[0][x] = background_color;
        canvas[bottom][x] = background_color;
     }
}


void setup(){
  clear_canvas();
}

void processInput(){
}

void update(){
}

void renderScene(){
}

void show(){
  for(int y = 0; y< canvas_height;y++){
     for(int x = 0; x< canvas_width;x++)
	    std::cout<<canvas[y][x];
     std::cout<<'\n';
  }
}

		
int main(){
	setup();

	while(1){
		processInput();
		update();
		renderScene();
	 	show();
	}
  

  return 0;
}
```



下面的代码还没来得及解释，先放出来

```cpp
#include <stdio.h>

#include <windows.h>

#include <iostream>

#include <conio.h>

using namespace std;

//=========辅助函数========

//--------光标定位---------

void gotoxy(int x, int y){
    COORD coord = {x, y};
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);
}

//--------隐藏光标---------

void HideCursor(){
 CONSOLE_CURSOR_INFO cursor_info = {1, 0};
 SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &cursor_info);
}

//==========画布==========
const int canvas_width = 50,canvas_height=20;
char canvas[canvas_height][canvas_width];

int  enemy_x = -1,enemy_y = -1;
int shooter_x,shooter_y;
int bullet_x,bullet_y;

#define background_color ' '

#define background_color_vertical '|'

#define background_color_norizonal '='

#define boundary_color '+'

#define enemy_color '@'

#define shooter_color '*'

#define bullet_color '|'

//---------清空画布--------

void clear_canvas(){
     for(int y = 0; y<canvas_height;y++)
		  for(int x = 0; x<canvas_width;x++)
              canvas[y][x] = background_color;
     int right  =canvas_width-1;
     for(int y = 0; y<canvas_height;y++){
        canvas[y][0] = background_color_vertical;
        canvas[y][right] = background_color_vertical;
     }
     int bottom  =canvas_height-1;
     for(int x = 0; x<canvas_width;x++){
        canvas[0][x] = background_color_norizonal;
        canvas[bottom][x] = background_color_norizonal;
     }
}

//------初始化------

void setup(){
     HideCursor();
	 enemy_x = canvas_width/2;
	 enemy_y = 2;

	 shooter_x = canvas_width/2;
	 shooter_y  = canvas_height-2;

	 bullet_x = -1; bullet_y = -1;

     clear_canvas();
}

//--------处理输入--------
void processInput(){
	char input;
	if(kbhit()){
		input = getch();
		if(input==' '){
		  bullet_x = shooter_x;
          bullet_y = shooter_y-1;
		}
		else if(input=='a'||input=='A'){
            if(shooter_x>0) shooter_x--;
		}
		else if(input=='d'||input=='D'){
            if(shooter_x<canvas_width-1)
                shooter_x++;
		}
		else if(input=='w'||input=='W'){
            if(shooter_y>0) shooter_y--;
		}
		else if(input=='s'||input=='S'){
            if(shooter_y<canvas_height-1)
                shooter_y++;
		}
	}

}

//--------更新数据--------
void update(){
  if(bullet_y>1) bullet_y--;
}

//---------绘制场景--------
void renderScene(){
    clear_canvas();

	if(enemy_x>=0&&enemy_x<canvas_width
    &&enemy_y>=0&&enemy_y<canvas_height)
		canvas[enemy_y][enemy_x] =  enemy_color;

    canvas[shooter_y][shooter_x] =  shooter_color;

	if(bullet_x>=0&&bullet_x<canvas_width&&bullet_y>=0
    &&bullet_y<canvas_height)
		canvas[bullet_y][bullet_x] =  bullet_color;
}

//---------显示画面----------

void show(){
    gotoxy(0,0);
	for(int y = 0; y< canvas_height;y++){
		  for(int x = 0; x< canvas_width;x++)
			  std::cout<<canvas[y][x];
		  std::cout<<'\n'; 
	}
	Sleep(5); //睡眠，降低画面刷新速度
	
}


int main()
{
	setup();

	while(1){
		processInput();
		update();
		renderScene();
	 	show();
	}
  

  return 0;
}


```
